After watching several inspiration videos and reading several articles about the implementation of such complex games using Python, for the implementation of my project, I made classes for each aspect of the game, from the chessboard as a whole, to the squares on the chessboard, to the pieces on the board, and many more. 

The main.py class controls the overall running of the game, responsible for showing the background and pieces of the game. It also contains the user’s actions, holding code on what should happen when users click, drag, and release, constantly updating the screen as new actions occur. Overall, it manages/oversees all the rest of the files, such as only placing a piece at a certain spot if that is known as a valid move for the chess piece, working off of the piece.py file, or keeping track of the moves made by the user inside the MoveTracker class within movetracker.py. Having this class is helpful in managing the game as a whole. The Chessboard class was made in order to create the 8 by 8 square chessboard. Within the class, it has various methods in relation to the pieces on the board, such as adding the pieces onto their respective locations in the beginning of the game, finding out what the possible moves are for the specific pieces on the chessboard, including the cases of whether a piece is in check, as well as features such as pawn promotion and checks. This class was helpful to create in order to manage the possibilities of the pieces on the board and manage the board. The game.py class handles more of the design of the chessboard, creating the colors in the alternating colors for the squares of the chessboard, showing the possible moves by highlighting the possible move squares in a reddish color, and keeping track of whose turn it is within the game, making it nice to have to make the game look nice and user-friendly.

While those classes handle a large portion of the overseeing of code, there are smaller classes such as the piece.py class, the drag.py class, and the square.py. The piece.py class handles the creation of the objects of the pieces by holding and setting the image of each piece, handling the moves that each piece can possibly do, and holds subclasses for the Piece class that have the classes for Pawn, Knight, Bishop, Rook, Queen, and King. This class allows for individuality for the pieces, all inheriting the characteristics of the superclass of Piece, but having each individual’s own characteristics as well. The drag.py class creates a Drag object that holds the x and y position of the mouse, and keeps track of where the drag starts and stops, and has the function that updates the screen with the image at the mouse’s location on the screen. This class was helpful to create as its own class as the drag feature could then be referred to in the main class when it refers to the user’s ability to press down on the mouse and release according to their preferences of dragging the piece to a certain location. The square.py class is a class that manages the squares within the chessboard, having the ability to check whether certain pieces are within the square or not, which was helpful in implementing functions further down the line with regards to seeing if a piece was in check or where the piece can move. 

Overall, after consulting resources on how to best organize a game as complex as chess, having these various classes for this chess game helped organize the multiple working parts of the game and have them work intertwined altogether.